(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{351:function(n,t,a){"use strict";a.r(t);var s=a(42),e=Object(s.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"函数对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数对象"}},[n._v("#")]),n._v(" 函数对象")]),n._v(" "),a("h2",{attrs:{id:"常见函数的四种类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见函数的四种类型"}},[n._v("#")]),n._v(" 常见函数的四种类型")]),n._v(" "),a("ul",[a("li",[n._v("匿名函数")]),n._v(" "),a("li",[n._v("回调函数")]),n._v(" "),a("li",[n._v("递归函数")]),n._v(" "),a("li",[n._v("构造函数")])]),n._v(" "),a("h2",{attrs:{id:"变量和函数的提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量和函数的提升"}},[n._v("#")]),n._v(" 变量和函数的提升")]),n._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[n._v("提示")]),n._v(" "),a("p",[n._v("js解析：预编译期 与执行期\n预编译预解析，解析时，会对所有声明的变量和函数进行处理，先预声明变量在定义函数\n变量声明提升，值停留在当前本地，函数整个代码提前，如果使用var fn声明函数，变量提前，函数体停留在本地")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("console.log(a); // undefined\nvar a = 10;\nfunction test() {\n    a = 100;\n    console.log(a); // 100 a声明提升\n    var a;\n    console.log(a); // 100\n    console.log(fun); // function fun() {}\n    console.log(fun1); // undefined\n}\nfunction fun() {};\ntest();\nvar fun1 = function() {};\nconsole.log(a) // 10不是100因为函数内的局部变量已经被释放，并且作用域到不了外面\n\n#提升过后的执行的代码\n\nvar a,fun1;\nconsole.log(a);\na = 10;\nfunction test() {\n    var a; // 没有声明的话，会将外面的a改掉\n    a = 100;\n    console.log(a); // 100 a声明提升\n    console.log(a); // 100\n    console.log(fun); // function fun() {}\n    console.log(fun1); // undefined\n}\nfunction fun() {};\ntest();\nfun1 = function() {};\nconsole.log(a);\n")])])]),a("h2",{attrs:{id:"作用域、作用链、执行环境、执行上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域、作用链、执行环境、执行上下文"}},[n._v("#")]),n._v(" 作用域、作用链、执行环境、执行上下文")]),n._v(" "),a("ul",[a("li",[n._v("全局作用域 window")]),n._v(" "),a("li",[n._v("函数作用域 function(){}")])]),n._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[n._v("提示")]),n._v(" "),a("p",[n._v("函数内可访问到外部的变量，外面访问不到函数内变量；\n函数创建时会指向他的作用链，先时他的本身函数作用域，在是全局作用域；\n执行环境（执行上下文）：全局执行环境和局部执行环境；变量对象、活动对象")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function a() {\n    function b() {\n        var bb = 234;\n    }\n    var a = 123;\n}\nvar glob = 12;\na();\nconsole.log(b) // 报错获取不到，bb a也一样\n\n\n#示例\nvar buttons = [{name: 'n1'}, {name: 'b2'}, {name: 'n3'}];\nfunction bind() {\n    for (var i = 0; i < buttons.length; i++) {\n        buttons[i].fun = function() {\n            alert(i);\n        }\n    }\n}\nbind();\nbuttons[0].fun(); //3\nbuttons[1].fun(); // 3\nbuttons[2].fun(); // 3\n\n// 立即执行可打印出0、1、2\n(function(num) {\n    buttons[i].fun = function() {\n        alert(num);\n    }\n})(i)\n")])])]),a("h2",{attrs:{id:"重载和多态的使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重载和多态的使用场景"}},[n._v("#")]),n._v(" 重载和多态的使用场景")]),n._v(" "),a("p",[n._v("重载：可以定义相同名字，不同参数的形式的不同函数，在调用的函数的时候，自动识别不同参数对应的函数，实现了相同函数名不同函数的调用；\njs本身没有重载，可通过arguments实现函数重载")]),n._v(" "),a("p",[n._v("多态：同一个东西在不同情况下表现不同状态：重写和重载")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 长方形和正方形面积x*x,x*y\nfunction react() {\n    //arguments 类数组\n    if (arguments.length >= 1) {\n        this.widht = arguments[0];\n        this.height = arguments[0];\n    }\n    if (arguments.length > 1) {\n        this.widht = arguments[0];\n        this.height = arguments[1];\n    }\n    this.toString = function() {\n        return 'width:' + this.width + ' height:' + this.height;\n    }\n}\n")])])]),a("h2",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[n._v("#")]),n._v(" 闭包")]),n._v(" "),a("p",[n._v("本质还是作用域问题；\n概念：引用了自由变量的函数，这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造他的环境也不例外；实现信息的驻留（信息的保持，引用在，空间不销毁）；")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("#简单闭包\nvar Person = function() {\n    var count = 0;\n    return function getCount() {\n        console.log(count++);\n    }\n}\nvar p = Person();\np(); // 0\np(); // 1\n")])])]),a("h2",{attrs:{id:"call、apply、bind使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call、apply、bind使用场景"}},[n._v("#")]),n._v(" call、apply、bind使用场景")]),n._v(" "),a("p",[n._v("属于Function对象上\napply方法能劫持另一个对象的方法，继承另一个对象的属性；\nFunction.apply(obj, args),接受两个参数\nobj：这个对象将代替Function类里的this对象，args数组\ncall，参数是单个传入，apply是数组传入\ncall和apply立即执行，bind需要一个变量接受之后在执行")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var stu1 = {\n    name: 'jack',\n    age: 18,\n    say: function(school, grade) {\n        console.log(this.name + '今年 ' + school + '年级' + grade);\n    }\n}\nvar stu2 = {\n    name: 'Tom'\n}\nstu1.say.apply(stu2, ['清华', '一'])// 此时stu1的方法say中的this。已经指向与stu2，所以name为Tom\nstu1.say.call(stu2, '清华', '一')\n\n\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[n._v("提示")]),n._v(" "),a("p",[n._v("lei数组转数组的应用：\nvar arr = Array.prototype.slice.apply(arguments)；\n// 手动实现bind方法\nFunction.prototype.newBind = function(obj) {\nvar self = this;\nreturn function() {\nself.apply(obj);\n}\n}")])]),n._v(" "),a("h2",{attrs:{id:"new的执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new的执行过程"}},[n._v("#")]),n._v(" new的执行过程")]),n._v(" "),a("p",[n._v("1、创建新对象\nvar obj = new Object();\n2、把obje的proto指向构造函数的prototype对象，实现继承，相关起来\nobj."),a("strong",[n._v("proto")]),n._v(" = Fn.prototype\n3、将obj作为this的上下文\nvar result = Fn.call(obj);\n4、返回创建的对象，如果函数没有返回对象，则返回this\nif (type result == 'object') {\nreturn result;\n} else {\nreturn obj\n}")]),n._v(" "),a("h2",{attrs:{id:"this-谁调用指向谁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this-谁调用指向谁"}},[n._v("#")]),n._v(" this 谁调用指向谁")]),n._v(" "),a("p",[n._v("指当前调用的这个对象： 4中绑定规则：默认绑定、隐私绑定、显示绑定、new绑定优先级有底到高\n改变this指向使用call、apply、bind")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var man = {\n    name: 'Tom',\n    age: 30,\n    getName: function() {\n        console.log(this.name)\n    },\n    getAge: function() {\n        function aa() { // 局部函数\n            console.log(this + ' ' + this.age) // 局部函数this执行的是window,所以this.age为undefined\n        }\n        aa(); // window.aa()\n        console.log(this + ' ' + this.age); // 30\n    }\n}\nman.getName() // getName中的this指向的man，所以打印的是Tom\nman.getAge()\n")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);